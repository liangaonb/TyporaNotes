#### TCP三次握手建立连接

**客户端 → 服务器**：`SYN` (Seq = X)

**服务器 → 客户端**：`SYN-ACK` (Seq = Y, Ack = X + 1)

**客户端 → 服务器**：`ACK` (Seq = X + 1, Ack = Y + 1)

1.客户端发送SYN包（同步请求）。客户端向服务器发送一个带有SYN标志的数据包。这个数据包的序列号（Sequence Number）设置为 `X`，表示客户端希望开始连接。**SYN** 表示“同步”请求，用于初始化连接。此时，客户端还没有数据传输，只是告知服务器它希望建立连接。

2.服务器响应SYN-ACK包（同步-确认）。服务器接收到客户端的SYN包后，若准备好建立连接，则返回一个带有SYN和ACK标志的数据包，表示它同意建立连接。该数据包的序列号设置为 `Y`，并且确认号设置为 `X + 1`，表示它已经收到了客户端的请求并愿意建立连接。此时，服务器将其自己的序列号 `Y` 发送给客户端，并确认客户端的序列号（`X + 1`）以确保客户端的请求已经被接收。

3.客户端确认ACK包（确认）。客户端接收到服务器的SYN-ACK包后，返回一个带有ACK标志的数据包，表示它已经收到了服务器的响应并且连接已经建立。此时，客户端的确认号设置为 `Y + 1`，确认服务器的序列号。此时，客户端完成了最后的确认，连接正式建立。

#### TCP四次挥手断开连接

**客户端 → 服务器**：客户端发送 `FIN` 包(Seq = X)，表示没有数据要发送了，准备断开连接。

**服务器 → 客户端**：服务器返回 `ACK` 包(Seq = Y, Ack = X + 1)，确认收到客户端的断开请求，但自己仍可以发送数据。

**服务器 → 客户端**：服务器发送 `FIN` 包(Seq = Y + 1)，表示它也准备好断开连接了。

**客户端 → 服务器**：客户端发送 `ACK` 包(Seq = X + 1, Ack = Y + 2)，确认收到服务器的断开请求，连接关闭。

1.客户端发送一个 **FIN**（结束）包，表示客户端已经没有数据要发送了，准备断开连接。`FIN` 标志位为 1，表示客户端的连接关闭请求。客户端进入 **FIN_WAIT_1** 状态，等待服务器的确认。

2.服务器收到客户端的 `FIN` 包后，返回一个 **ACK** 包，表示它已经收到客户端的关闭请求，并且确认客户端已经完成数据发送。服务器会给出确认号 `Ack = X + 1`，表示客户端发送的最后一个字节的数据已经被接收到。服务器进入 **CLOSE_WAIT** 状态，表示它已经准备好关闭自己的连接，但它仍然可以继续发送数据。

3.服务器准备关闭连接后，它会向客户端发送一个 **FIN** 包，表示服务器已经没有数据要发送了，并准备断开连接。服务器进入 **LAST_ACK** 状态，等待客户端的确认。

4.客户端收到服务器的 `FIN` 包后，发送一个 **ACK** 包，表示客户端已收到服务器的关闭请求，并确认服务器可以关闭连接。客户端进入 **TIME_WAIT** 状态，等待一段时间以确保服务器接收到 ACK 包，然后客户端可以完全关闭连接。

#### HTTP1、1.1、2、3有什么区别？



#### HTTP和HTTPS的区别？



#### TCP的粘包是什么，如何解决？



#### 对HTTPS协议进行改进，把传输层协议从TCP换为UDP，如何做？改换后要在这个基础上实现可靠传输，如何做？



#### 以Linux系统上的ls命令举例，详细介绍命令背后的整体执行流程，包括是如何从用户态到内核态再返回的？

1. **用户输入命令**：用户在 shell 中输入 `ls` 命令。
2. **shell 解析命令**：shell 解析命令并调用 `execve` 系统调用。
3. **内核加载程序**：内核加载 `ls` 可执行文件并创建进程。
4. **执行 `ls` 程序**：`ls` 程序通过系统调用与内核交互，获取目录内容。
5. **内核处理系统调用**：CPU 切换到内核态，并跳转到系统调用处理程序。内核访问文件系统，读取目录内容或文件元数据。内核将目录内容返回给 `ls` 程序。CPU 切换回用户态，程序继续执行。
6. **输出结果**：`ls` 程序将读取到的目录内容格式化后输出到标准输出（通常是终端）。
7. **进程结束**：`ls` 进程结束，控制权返回给 shell。

#### BIOS是存在哪的？从哪加载的？

BIOS（Basic Input/Output System，基本输入输出系统）是计算机启动时运行的第一个软件，它存储在主板上的一个特定的硬件芯片中。计算机通电后，CPU 会从固定的内存地址开始执行指令，这个地址指向 BIOS 芯片中的代码。BIOS 首先执行 POST（Power-On Self-Test，上电自检），检查硬件设备（如内存、CPU、硬盘、显卡等）是否正常工作，如果 POST 过程中发现错误，BIOS 会通过蜂鸣声或屏幕显示错误代码来提示用户。然后BIOS 会读取 CMOS（Complementary Metal-Oxide-Semiconductor，互补金属氧化物半导体）中的配置信息，根据 CMOS 中配置的启动顺序（如硬盘、光盘、USB 等）查找可启动设备。BIOS 会读取设备的引导扇区（如 MBR，主引导记录）并加载引导加载程序（如 GRUB）。BIOS 将控制权交给引导加载程序，引导加载程序负责加载操作系统内核。

#### 什么是线程池？

线程池是一种常用的并发编程技术，用于管理和复用线程资源，以提高程序的性能和资源利用率。线程池的核心思想是预先创建一组线程，并将任务分配给这些线程，而不是每次执行任务时都创建和销毁线程。这种方式可以减少线程创建和销毁的开销，同时避免系统资源的过度消耗。线程池维护一个任务队列，用于存储待执行的任务，工作线程从任务队列中获取任务并执行。

#### 函数调用的过程中底层发生了什么？

1. **函数调用前**

- **准备调用参数：**
  - 在函数调用之前，程序需要准备好调用所需的参数。参数可以是通过寄存器或栈传递的，具体方式取决于编译器的约定。
  - 在 **x86** 架构中，前几个参数通常通过寄存器传递。其他参数则会压入栈中。对于 **x64** 架构，通常通过 **RDI**、**RSI**、**RDX** 等寄存器传递前六个参数，超过六个的参数则会通过栈传递。
- **保存当前状态：**
  - 程序当前的执行上下文（如寄存器的值）需要保存，以便在函数返回后能够恢复。

2. **函数调用时**

- **栈帧的创建：**
  - 在调用函数时，系统会为这个函数调用创建一个新的栈帧（stack frame）。栈帧用于存储该函数调用所需的数据，包括：
    - **返回地址**：当函数执行完毕后，程序需要跳转回原来的位置。返回地址通常是调用指令的下一条指令地址。
    - **保存寄存器的值**：调用函数可能会修改寄存器，因此在函数调用之前需要保存寄存器的值，以便返回时能够恢复。
    - **参数**：函数调用的参数需要被压入栈中（如果没有通过寄存器传递的话）。
    - **局部变量**：函数内部的局部变量也会分配空间，通常是在栈上分配。
- **控制流转移：**
  - 当程序执行到函数调用指令时，程序控制权转移到函数的入口地址。此时，程序的 **指令指针（IP/PC）** 会跳转到函数的地址，开始执行该函数的代码。
- **函数参数的传递：**
  - 根据调用约定（如 **cdecl**、**stdcall** 等），函数的参数会被压入栈中或通过寄存器传递给函数。不同平台和编译器可能会有不同的调用约定。

3. **函数执行时**

- **局部变量的分配：**
  - 在函数内部，会根据需要分配栈空间来存储局部变量。每个局部变量的生命周期在函数调用期间有效，当函数返回时这些局部变量会被销毁。
- **寄存器使用：**
  - 在函数执行时，CPU 的寄存器可能会被用来存储中间结果或函数的返回值。例如，在 **x86** 或 **x64** 架构中，函数返回值通常存储在 **EAX** 或 **RAX** 寄存器中。
- **栈帧的调整：**
  - 函数在执行过程中，可能会使用栈来存储临时数据或者保存中间状态。执行过程中，如果有递归调用，栈帧会不断地压入新的栈帧，形成一个栈的“深度”。

4. **函数返回时**

- **清理栈帧：**
  - 当函数执行完成并准备返回时，栈帧需要被清理。这通常是通过调整栈指针来完成的，栈指针会恢复到函数调用之前的位置。
  - 返回值通常会放在寄存器（如 **EAX** 或 **RAX**）中。如果返回值较大，也可能通过栈传递。
- **恢复寄存器的值：**
  - 如果函数调用修改了寄存器的值，返回时会将保存的寄存器值恢复回原来的状态，以确保调用函数前的程序状态保持一致。
- **返回控制流：**
  - 当函数准备返回时，程序会从栈中取出 **返回地址**，这个地址是函数调用时保存的地址。程序控制流会跳转到这个地址，继续执行函数调用后的代码。

#### 线程的通信方式？
