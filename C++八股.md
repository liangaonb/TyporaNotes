#### 什么是完美转发？

完美转发确保了在转发函数参数时，参数的值类别（左值或右值）不会被改变，允许你有效地利用右值引用的优势，避免不必要的拷贝，同时保持代码的灵活性。它通过右值引用和 `std::forward` 来实现。

#### 动态库与静态库的含义、区别及选择

静态库(.lib)是在编译时直接嵌入到目标程序中的一组函数或代码的集合。生成的可执行文件包含了静态库的代码，因此可以独立运行，不依赖外部库文件。动态库(.dll)是在程序运行时由操作系统加载的库文件。可执行文件中只保存对动态库的引用，动态库的代码在运行时加载，多个程序可以共享同一动态库文件。

![image-20241225105331052](C++八股_markdown_image/image-20241225105331052.png)

#### dynamic_cast的原理，如何自行实现？

`dynamic_cast` 的工作原理基于**运行时类型信息（RTTI）**。RTTI 是 C++ 在编译时生成的一些信息，帮助程序在运行时确定对象的实际类型，尤其是当涉及多态（虚函数）时，允许程序检查一个对象的实际类型。每个包含虚函数的类都有一个与之相关的类型信息结构（`type_info`），`dynamic_cast` 使用这个结构来判断对象的实际类型。

当执行 `dynamic_cast` 时，编译器会利用虚函数表中的信息来进行类型检查。虚函数表通常包含一个指向 `type_info` 的指针（不是标准规范的一部分，但多数实现如此），这个指针指向与该类关联的 `type_info` 对象，该对象包含类的类型信息。

具体步骤如下：

1. **类型识别**：通过虚指针查找对象的类型信息（`type_info`），与目标类型的 `type_info` 进行比较。
2. **向下转换时检查类型匹配**：在进行向下转换时，`dynamic_cast` 会首先检查目标类型是否与对象的实际类型匹配。如果匹配，则返回转换后的指针或引用，否则返回 `nullptr`（指针类型）或抛出 `std::bad_cast` 异常（引用类型）。

#### C++类对象的内存模型（布局）

**虚函数表（vtable）的布局**

- 如果类中有虚函数，编译器会为该类生成一个虚函数表（vtable），并在对象的内存布局中插入一个指向该虚函数表的指针（称为`vptr`）。
- `vptr`通常位于对象内存布局的**最开头**（即最低地址处），这是为了确保动态绑定的高效性。
- 虚函数表中存储的是虚函数的地址。如果子类重写了父类的虚函数，子类的虚函数表中会更新为子类的函数地址。

**成员变量的布局**

- 成员变量按照**声明顺序**在内存中排列。
- 如果存在继承关系，父类的成员变量会先于子类的成员变量排列。
- 编译器可能会在成员变量之间插入**填充字节（padding）**，以满足对齐要求（alignment）。对齐的目的是提高内存访问效率。

**多继承的内存布局**

- 在多继承中，每个包含虚函数的父类都会有自己的`vptr`和虚函数表。
- 子类的内存布局会按照继承顺序排列：先排列第一个父类的`vptr`和成员变量，然后是第二个父类的`vptr`和成员变量，依此类推，最后是子类自己的成员变量。
- 如果子类重写了父类的虚函数，每个父类的虚函数表中对应的函数地址会被更新为子类的函数地址。
- 如果子类定义了新的虚函数，这些虚函数的地址会被添加到**第一个父类的虚函数表**中。

**虚继承的内存布局**

- 虚继承用于解决**钻石继承（菱形继承）**问题，确保公共基类在派生类中只有一份实例。
- 在虚继承中，公共基类的成员变量会被放置在派生类内存布局的**最后**。
- 每个虚继承的父类会包含一个指向公共基类的指针（通常是`vbptr`，即虚基类表指针），用于在运行时定位公共基类的成员变量。
- 虚继承会增加内存开销和运行时成本，因为需要通过`vbptr`间接访问公共基类的成员。

------

**补充说明**

- **空类**：如果一个类是空的（没有成员变量和虚函数），它的大小通常为1字节，以确保每个对象都有唯一的地址。
- **静态成员变量**：静态成员变量不属于类的实例，因此不会影响对象的内存布局。
- **对齐（alignment）**：编译器会根据平台的对齐要求对成员变量进行对齐，这可能会导致内存布局中存在填充字节。

#### 多继承中的虚函数表

父类的虚函数表（vtable）在编译时就已经确定，并且是**静态的**。它不会因为子类的存在或子类的行为而改变。父类的虚函数表存储在程序的只读数据段（`.rodata`），是不可修改的。

子类的虚函数表是基于父类的虚函数表生成的，当子类继承父类时，编译器会为子类生成一个新的虚函数表。这个新的虚函数表**最初是父类虚函数表的拷贝**，但它是子类独有的，存储在子类的内存空间中。如果子类重写了父类的虚函数，编译器会更新子类的虚函数表中对应的函数地址，替换为子类的实现。在多继承中，子类会为每个父类维护一个独立的虚函数表。这些虚函数表是子类的一部分，存储在子类的内存空间中。如果子类重写了某个父类的虚函数，子类会更新该父类对应的虚函数表。

#### STL

##### vector

**vector的resize和reserve有什么区别?**

resize()调整 `vector` 的大小。如果新大小大于当前大小，会添加默认构造的元素（或者指定的值）。如果新大小小于当前大小，会丢弃尾部的元素。reserve()为 `vector` 预留足够的内存，以容纳至少 `n` 个元素。通过减少动态扩容的次数来提高性能。如果当前容量小于 `new_capacity`，`vector` 将重新分配内存并增加容量。如果当前容量已经足够，`reserve()` 不会做任何改变。`reserve()` 仅影响容量，不会改变 `vector` 的大小（`size()`）。

**vector是分配在堆上还是栈上？sizeof（vector）返回什么值?**

当创建一个 `std::vector` 时，`std::vector` 对象本身（即控制结构）会分配在栈上，但存储元素的内存是通过堆进行分配的。`vector` 管理着这块堆内存，负责根据元素的数量自动调整容量。`sizeof(std::vector)` 返回的是 **`vector` 对象本身（即控制结构）的大小**，而不是它存储元素的内存大小。`sizeof(vec)` 可能会返回 24（视平台而定），因为 `std::vector` 的控制结构包含指向数据的指针、`size_t` 类型的大小和容量值。

`std::vector` 自身会管理内存，无需额外使用 `new` 来动态分配存储空间，只需要创建 `std::vector` 对象即可。`std::vector` 会自动在堆上分配和释放内存。通常情况下，C++ 标准库的容器如 `std::vector` 都会通过栈分配，或者通过智能指针进行动态管理，而不需要直接使用 `new` 来分配容器对象。

**vector扩容一定都要开辟再拷贝吗？能不能在原来的基础上开辟？**

通常而言不行，如果当前内存块的后面没有足够的连续空间来扩展，就无法在原来的基础上直接扩容，必须重新分配一块更大的内存。可以通过为 `std::vector` 实现一个自定义的内存分配器以控制内存分配行为。例如，可以尝试在重新分配时复用之前的内存块。

##### map & unordered_map

**unordered_map中插入一个元素，它原来的iterator还有效吗?**

**如果插入的新元素不会导致哈希表扩容**，原来的 iterator 是**有效的**。**如果插入的操作导致哈希表扩容**，原来的 iterator 就**不再有效**。`std::unordered_map` 是基于哈希表实现的。哈希表的底层数据结构通常是一个数组，每个桶(bucket)存储一个链表或其他形式的容器。如果插入新元素时，哈希表的容量不足以容纳更多元素，它会触发扩容操作（通常是将数组的大小扩大一倍）。扩容时，哈希表内部的所有元素会被重新哈希，并可能移动到新的桶中。因此，插入元素时如果发生了扩容，所有原来的 iterators 都会失效。

**map中插入一个元素，它原来的iterator还有效吗?**

在 `std::map` 中插入一个新元素**不会**使其他现有的迭代器失效，因为 `std::map` 的底层实现（红黑树）在插入新元素时可能会导致树的结构调整（例如旋转），但这些调整不会影响已有节点的内存地址，红黑树的节点不会被重新分配，只是调整指针，不会使迭代器失效。

**为什么红黑树插入删除效率高？**

**AVL树** 要求更严格的平衡（左右子树高度差不超过1），因此查找操作更快（更适合查找密集型任务），**红黑树** 的平衡要求相对宽松，因此在插入和删除操作中需要更少的旋转操作，适合插入和删除频繁的场景。

#### 智能指针

**shared_ptr是不是线程安全的，为什么?**

`shared_ptr` 使用原子操作来管理引用计数。多个线程同时拷贝、赋值或销毁同一个 `shared_ptr` 时，引用计数的增减是线程安全的。即使多个线程同时操作同一个 `shared_ptr`，引用计数也不会出错，对象的生命周期管理是安全的。`shared_ptr` 只保证引用计数的线程安全，**不保证其管理的对象的线程安全**。如果多个线程同时访问或修改 `shared_ptr` 管理的对象，需要额外的同步机制（如互斥锁）来保证线程安全。此外，虽然引用计数是线程安全的，但 `shared_ptr` 本身的操作（如赋值、重置等）并不是线程安全的。

**把unique_ptr move到shared_ptr会发生什么?**

1. `std::shared_ptr` 接管 `std::unique_ptr` 所管理的资源（即指针指向的对象）。
2. `std::unique_ptr` 会释放对资源的所有权，并将其内部指针设置为 `nullptr`。
3. `std::shared_ptr` 开始管理资源，并初始化其引用计数为 1。

该操作是高效的，它避免了额外的资源拷贝或分配，只是简单地转移资源的所有权。

**unique_ptr可以作为返回值吗**

返回 `std::unique_ptr` 时，编译器会自动调用移动构造函数或移动赋值运算符，将资源的所有权转移给调用者，避免内存泄漏和额外的拷贝开销。

#### 解释一下inline函数，inline函数可以是虚函数吗

`inline` 关键字用于建议编译器将函数体直接展开到调用处，从而避免函数调用的开销（如压栈、跳转、返回等）。它的主要用途是优化小型、频繁调用的函数。`inline` 函数的定义通常放在头文件中，因为编译器需要在每个调用处看到函数体。虚函数的主要特性是动态绑定（运行时多态），而 `inline` 是静态绑定（编译时展开）。如果虚函数通过基类指针或引用调用，编译器无法在编译时确定具体调用哪个派生类的函数，因此无法内联。因此，将虚函数声明为 `inline` 的实际意义不大，不推荐这样做。

#### 内存泄漏有什么解决方式

1.使用智能指针。C++11 引入了智能指针（如 `std::unique_ptr` 和 `std::shared_ptr`），它们可以自动管理动态内存的生命周期，避免手动释放内存的繁琐和错误。

2.遵循 RAII 原则。RAII（Resource Acquisition Is Initialization）是 C++ 的核心编程范式，通过对象的构造函数分配资源，析构函数释放资源，确保资源管理的安全性。

可以通过重载 `new` 和 `delete` 运算符，记录内存分配和释放的情况，帮助定位内存泄漏。
